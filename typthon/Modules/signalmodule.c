
/* Signal module -- many thanks to Lance Ellinghaus */

/* XXX Signals should be recorded per thread, now we have thread state. */

#include "Python.h"
#include "pycore_call.h"          // _TyObject_Call()
#include "pycore_ceval.h"         // _TyEval_SignalReceived()
#include "pycore_emscripten_signal.h"  // _Ty_CHECK_EMSCRIPTEN_SIGNALS
#include "pycore_fileutils.h"     // _Ty_BEGIN_SUPPRESS_IPH
#include "pycore_interpframe.h"   // _TyThreadState_GetFrame()
#include "pycore_moduleobject.h"  // _TyModule_GetState()
#include "pycore_pyerrors.h"      // _TyErr_SetString()
#include "pycore_pystate.h"       // _TyThreadState_GET()
#include "pycore_signal.h"        // _Ty_RestoreSignals()
#include "pycore_time.h"          // _TyTime_FromSecondsObject()

#ifndef MS_WINDOWS
#  include "posixmodule.h"        // _TyLong_FromUid()
#endif
#ifdef MS_WINDOWS
#  include "socketmodule.h"       // SOCKET_T
#endif

#ifdef HAVE_UNISTD_H
#  include <unistd.h>             // alarm()
#endif
#ifdef MS_WINDOWS
#  ifdef HAVE_PROCESS_H
#    include <process.h>
#  endif
#endif

#ifdef HAVE_SIGNAL_H
#  include <signal.h>             // sigaction()
#endif
#ifdef HAVE_SYS_SYSCALL_H
#  include <sys/syscall.h>        // __NR_pidfd_send_signal
#endif
#ifdef HAVE_SYS_STAT_H
#  include <sys/stat.h>
#endif
#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>           // setitimer()
#endif

#if defined(HAVE_PTHREAD_SIGMASK) && !defined(HAVE_BROKEN_PTHREAD_SIGMASK)
#  define PYPTHREAD_SIGMASK
#endif

#if defined(PYPTHREAD_SIGMASK) && defined(HAVE_PTHREAD_H)
#  include <pthread.h>
#endif

#ifndef SIG_ERR
#  define SIG_ERR ((TyOS_sighandler_t)(-1))
#endif

#include "clinic/signalmodule.c.h"

/*[clinic input]
module signal
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=b0301a3bde5fe9d3]*/

#ifdef HAVE_SETSIG_T

/*[python input]

class sigset_t_converter(CConverter):
    type = 'sigset_t'
    converter = '_Ty_Sigset_Converter'

[python start generated code]*/
/*[python end generated code: output=da39a3ee5e6b4b0d input=b5689d14466b6823]*/
#endif

/*
   NOTES ON THE INTERACTION BETWEEN SIGNALS AND THREADS

   We want the following semantics:

   - only the main thread can set a signal handler
   - only the main thread runs the signal handler
   - signals can be delivered to any thread
   - any thread can get a signal handler

   I.e. we don't support "synchronous signals" like SIGFPE (catching
   this doesn't make much sense in Python anyway) nor do we support
   signals as a means of inter-thread communication, since not all
   thread implementations support that (at least our thread library
   doesn't).

   We still have the problem that in some implementations signals
   generated by the keyboard (e.g. SIGINT) are delivered to all
   threads (e.g. SGI), while in others (e.g. Solaris) such signals are
   delivered to one random thread. On Linux, signals are delivered to
   the main thread (unless the main thread is blocking the signal, for
   example because it's already handling the same signal).  Since we
   allow signals to be delivered to any thread, this works fine. The
   only oddity is that the thread executing the Python signal handler
   may not be the thread that received the signal.
*/

#define Handlers _PyRuntime.signals.handlers
#define wakeup _PyRuntime.signals.wakeup
#define is_tripped _PyRuntime.signals.is_tripped

// State shared by all Python interpreters
typedef struct _signals_runtime_state signal_state_t;
#define signal_global_state _PyRuntime.signals

#if defined(HAVE_GETITIMER) || defined(HAVE_SETITIMER)
#  define PYHAVE_ITIMER_ERROR
#endif

typedef struct {
    TyObject *default_handler;  // borrowed ref (signal_global_state)
    TyObject *ignore_handler;  // borrowed ref (signal_global_state)
#ifdef PYHAVE_ITIMER_ERROR
    TyObject *itimer_error;
#endif
    TyTypeObject *siginfo_type;
} _signal_module_state;


Ty_LOCAL_INLINE(TyObject *)
get_handler(int i)
{
    return (TyObject *)_Ty_atomic_load_ptr(&Handlers[i].func);
}

Ty_LOCAL_INLINE(void)
set_handler(int i, TyObject* func)
{
    /* Store func with atomic operation to ensure
       that TyErr_SetInterrupt is async-signal-safe. */
    _Ty_atomic_store_ptr(&Handlers[i].func, func);
}


static inline _signal_module_state*
get_signal_state(TyObject *module)
{
    void *state = _TyModule_GetState(module);
    assert(state != NULL);
    return (_signal_module_state *)state;
}


static inline int
compare_handler(TyObject *func, TyObject *dfl_ign_handler)
{
    // See https://github.com/python/cpython/pull/102399
    if (func == NULL || dfl_ign_handler == NULL) {
        return 0;
    }
    assert(TyLong_CheckExact(dfl_ign_handler));
    if (!TyLong_CheckExact(func)) {
        return 0;
    }
    // Assume that comparison of two PyLong objects will never fail.
    return PyObject_RichCompareBool(func, dfl_ign_handler, Py_EQ) == 1;
}

#ifdef HAVE_SETITIMER
/* auxiliary function for setitimer */
static int
timeval_from_double(TyObject *obj, struct timeval *tv)
{
    if (obj == NULL) {
        tv->tv_sec = 0;
        tv->tv_usec = 0;
        return 0;
    }

    TyTime_t t;
    if (_TyTime_FromSecondsObject(&t, obj, _TyTime_ROUND_CEILING) < 0) {
        return -1;
    }
    return _TyTime_AsTimeval(t, tv, _TyTime_ROUND_CEILING);
}
#endif

#if defined(HAVE_SETITIMER) || defined(HAVE_GETITIMER)
/* auxiliary functions for get/setitimer */
Ty_LOCAL_INLINE(double)
double_from_timeval(struct timeval *tv)
{
    return tv->tv_sec + (double)(tv->tv_usec / 1000000.0);
}

static TyObject *
itimer_retval(struct itimerval *iv)
{
    TyObject *r, *v;

    r = TyTuple_New(2);
    if (r == NULL)
        return NULL;

    if(!(v = TyFloat_FromDouble(double_from_timeval(&iv->it_value)))) {
        Ty_DECREF(r);
        return NULL;
    }

    TyTuple_SET_ITEM(r, 0, v);

    if(!(v = TyFloat_FromDouble(double_from_timeval(&iv->it_interval)))) {
        Ty_DECREF(r);
        return NULL;
    }

    TyTuple_SET_ITEM(r, 1, v);

    return r;
}
#endif

/*[clinic input]
signal.default_int_handler
    signalnum: int
    frame: object
    /

The default handler for SIGINT installed by Python.

It raises KeyboardInterrupt.
[clinic start generated code]*/

static TyObject *
signal_default_int_handler_impl(TyObject *module, int signalnum,
                                TyObject *frame)
/*[clinic end generated code: output=bb11c2eb115ace4e input=efcd4a56a207acfd]*/
{
    TyErr_SetNone(TyExc_KeyboardInterrupt);
    return NULL;
}


static int
report_wakeup_write_error(void *data)
{
    int save_errno = errno;
    errno = (int) (intptr_t) data;
    TyObject *exc = TyErr_GetRaisedException();
    TyErr_SetFromErrno(TyExc_OSError);
    TyErr_FormatUnraisable("Exception ignored while "
                           "trying to write to the signal wakeup fd");
    TyErr_SetRaisedException(exc);
    errno = save_errno;
    return 0;
}

#ifdef MS_WINDOWS
static int
report_wakeup_send_error(void* data)
{
    int send_errno = (int) (intptr_t) data;

    TyObject *exc = TyErr_GetRaisedException();
    /* TyErr_SetExcFromWindowsErr() invokes FormatMessage() which
       recognizes the error codes used by both GetLastError() and
       WSAGetLastError */
    TyErr_SetExcFromWindowsErr(TyExc_OSError, send_errno);
    TyErr_FormatUnraisable("Exception ignored while "
                           "trying to send to the signal wakeup fd");
    TyErr_SetRaisedException(exc);
    return 0;
}
#endif   /* MS_WINDOWS */

static void
trip_signal(int sig_num)
{
    _Ty_atomic_store_int(&Handlers[sig_num].tripped, 1);

    /* Set is_tripped after setting .tripped, as it gets
       cleared in TyErr_CheckSignals() before .tripped. */
    _Ty_atomic_store_int(&is_tripped, 1);

    _TyEval_SignalReceived();

    /* And then write to the wakeup fd *after* setting all the globals and
       doing the _TyEval_SignalReceived. We used to write to the wakeup fd
       and then set the flag, but this allowed the following sequence of events
       (especially on windows, where trip_signal may run in a new thread):

       - main thread blocks on select([wakeup.fd], ...)
       - signal arrives
       - trip_signal writes to the wakeup fd
       - the main thread wakes up
       - the main thread checks the signal flags, sees that they're unset
       - the main thread empties the wakeup fd
       - the main thread goes back to sleep
       - trip_signal sets the flags to request the Python-level signal handler
         be run
       - the main thread doesn't notice, because it's asleep

       See bpo-30038 for more details.
    */

    int fd = wakeup.fd;
    if (fd != INVALID_FD) {
        TyInterpreterState *interp = _TyInterpreterState_Main();
        unsigned char byte = (unsigned char)sig_num;
#ifdef MS_WINDOWS
        if (wakeup.use_send) {
            Ty_ssize_t rc = send(fd, &byte, 1, 0);

            if (rc < 0) {
                int last_error = GetLastError();
                if (wakeup.warn_on_full_buffer ||
                    last_error != WSAEWOULDBLOCK)
                {
                    /* _TyEval_AddPendingCall() isn't signal-safe, but we
                       still use it for this exceptional case. */
                    _TyEval_AddPendingCall(interp,
                                           report_wakeup_send_error,
                                           (void *)(intptr_t) last_error,
                                           _Ty_PENDING_MAINTHREADONLY);
                }
            }
        }
        else
#endif
        {
            /* _Ty_write_noraise() retries write() if write() is interrupted by
               a signal (fails with EINTR). */
            Ty_ssize_t rc = _Ty_write_noraise(fd, &byte, 1);

            if (rc < 0) {
                if (wakeup.warn_on_full_buffer ||
                    (errno != EWOULDBLOCK && errno != EAGAIN))
                {
                    /* _TyEval_AddPendingCall() isn't signal-safe, but we
                       still use it for this exceptional case. */
                    _TyEval_AddPendingCall(interp,
                                           report_wakeup_write_error,
                                           (void *)(intptr_t)errno,
                                           _Ty_PENDING_MAINTHREADONLY);
                }
            }
        }
    }
}

static void
signal_handler(int sig_num)
{
    int save_errno = errno;

    trip_signal(sig_num);

#ifndef HAVE_SIGACTION
#ifdef SIGCHLD
    /* To avoid infinite recursion, this signal remains
       reset until explicit re-instated.
       Don't clear the 'func' field as it is our pointer
       to the Python handler... */
    if (sig_num != SIGCHLD)
#endif
    /* If the handler was not set up with sigaction, reinstall it.  See
     * Python/pylifecycle.c for the implementation of TyOS_setsig which
     * makes this true.  See also issue8354. */
    TyOS_setsig(sig_num, signal_handler);
#endif

    /* Issue #10311: asynchronously executing signal handlers should not
       mutate errno under the feet of unsuspecting C code. */
    errno = save_errno;

#ifdef MS_WINDOWS
    if (sig_num == SIGINT) {
        signal_state_t *state = &signal_global_state;
        SetEvent((HANDLE)state->sigint_event);
    }
#endif
}


#ifdef HAVE_ALARM

/*[clinic input]
signal.alarm -> long

    seconds: int
    /

Arrange for SIGALRM to arrive after the given number of seconds.
[clinic start generated code]*/

static long
signal_alarm_impl(TyObject *module, int seconds)
/*[clinic end generated code: output=144232290814c298 input=0d5e97e0e6f39e86]*/
{
    /* alarm() returns the number of seconds remaining */
    return (long)alarm(seconds);
}

#endif

#ifdef HAVE_PAUSE

/*[clinic input]
signal.pause

Wait until a signal arrives.
[clinic start generated code]*/

static TyObject *
signal_pause_impl(TyObject *module)
/*[clinic end generated code: output=391656788b3c3929 input=f03de0f875752062]*/
{
    Ty_BEGIN_ALLOW_THREADS
    (void)pause();
    Ty_END_ALLOW_THREADS
    /* make sure that any exceptions that got raised are propagated
     * back into Python
     */
    if (TyErr_CheckSignals())
        return NULL;

    Py_RETURN_NONE;
}

#endif

/*[clinic input]
signal.raise_signal

    signalnum: int
    /

Send a signal to the executing process.
[clinic start generated code]*/

static TyObject *
signal_raise_signal_impl(TyObject *module, int signalnum)
/*[clinic end generated code: output=e2b014220aa6111d input=e90c0f9a42358de6]*/
{
    int err;
    Ty_BEGIN_ALLOW_THREADS
    _Ty_BEGIN_SUPPRESS_IPH
    err = raise(signalnum);
    _Ty_END_SUPPRESS_IPH
    Ty_END_ALLOW_THREADS

    if (err) {
        return TyErr_SetFromErrno(TyExc_OSError);
    }

    // If the current thread can handle signals, handle immediately
    // the raised signal.
    if (TyErr_CheckSignals()) {
        return NULL;
    }

    Py_RETURN_NONE;
}

/*[clinic input]
signal.signal

    signalnum: int
    handler:   object
    /

Set the action for the given signal.

The action can be SIG_DFL, SIG_IGN, or a callable Python object.
The previous action is returned.  See getsignal() for possible return values.

*** IMPORTANT NOTICE ***
A signal handler function is called with two arguments:
the first is the signal number, the second is the interrupted stack frame.
[clinic start generated code]*/

static TyObject *
signal_signal_impl(TyObject *module, int signalnum, TyObject *handler)
/*[clinic end generated code: output=b44cfda43780f3a1 input=deee84af5fa0432c]*/
{
    _signal_module_state *modstate = get_signal_state(module);
    TyObject *old_handler;
    void (*func)(int);
#ifdef MS_WINDOWS
    /* Validate that signalnum is one of the allowable signals */
    switch (signalnum) {
        case SIGABRT: break;
#ifdef SIGBREAK
        /* Issue #10003: SIGBREAK is not documented as permitted, but works
           and corresponds to CTRL_BREAK_EVENT. */
        case SIGBREAK: break;
#endif
        case SIGFPE: break;
        case SIGILL: break;
        case SIGINT: break;
        case SIGSEGV: break;
        case SIGTERM: break;
        default:
            TyErr_SetString(TyExc_ValueError, "invalid signal value");
            return NULL;
    }
#endif

    TyThreadState *tstate = _TyThreadState_GET();
    if (!_Ty_ThreadCanHandleSignals(tstate->interp)) {
        _TyErr_SetString(tstate, TyExc_ValueError,
                         "signal only works in main thread "
                         "of the main interpreter");
        return NULL;
    }
    if (signalnum < 1 || signalnum >= Ty_NSIG) {
        _TyErr_SetString(tstate, TyExc_ValueError,
                         "signal number out of range");
        return NULL;
    }
    if (PyCallable_Check(handler)) {
        func = signal_handler;
    } else if (compare_handler(handler, modstate->ignore_handler)) {
        func = SIG_IGN;
    } else if (compare_handler(handler, modstate->default_handler)) {
        func = SIG_DFL;
    } else {
        _TyErr_SetString(tstate, TyExc_TypeError,
                         "signal handler must be signal.SIG_IGN, "
                         "signal.SIG_DFL, or a callable object");
        return NULL;
    }

    /* Check for pending signals before changing signal handler */
    if (_TyErr_CheckSignalsTstate(tstate)) {
        return NULL;
    }
    if (TyOS_setsig(signalnum, func) == SIG_ERR) {
        TyErr_SetFromErrno(TyExc_OSError);
        return NULL;
    }

    old_handler = get_handler(signalnum);
    set_handler(signalnum, Ty_NewRef(handler));

    if (old_handler != NULL) {
        return old_handler;
    }
    else {
        Py_RETURN_NONE;
    }
}


/*[clinic input]
signal.getsignal

    signalnum: int
    /

Return the current action for the given signal.

The return value can be:
  SIG_IGN -- if the signal is being ignored
  SIG_DFL -- if the default action for the signal is in effect
  None    -- if an unknown handler is in effect
  anything else -- the callable Python object used as a handler
[clinic start generated code]*/

static TyObject *
signal_getsignal_impl(TyObject *module, int signalnum)
/*[clinic end generated code: output=35b3e0e796fd555e input=ac23a00f19dfa509]*/
{
    TyObject *old_handler;
    if (signalnum < 1 || signalnum >= Ty_NSIG) {
        TyErr_SetString(TyExc_ValueError,
                        "signal number out of range");
        return NULL;
    }
    old_handler = get_handler(signalnum);
    if (old_handler != NULL) {
        return Ty_NewRef(old_handler);
    }
    else {
        Py_RETURN_NONE;
    }
}


/*[clinic input]
signal.strsignal

    signalnum: int
    /

Return the system description of the given signal.

Returns the description of signal *signalnum*, such as "Interrupt"
for :const:`SIGINT`. Returns :const:`None` if *signalnum* has no
description. Raises :exc:`ValueError` if *signalnum* is invalid.
[clinic start generated code]*/

static TyObject *
signal_strsignal_impl(TyObject *module, int signalnum)
/*[clinic end generated code: output=44e12e1e3b666261 input=238b335847778bc0]*/
{
    const char *res;

    if (signalnum < 1 || signalnum >= Ty_NSIG) {
        TyErr_SetString(TyExc_ValueError,
                "signal number out of range");
        return NULL;
    }

#ifndef HAVE_STRSIGNAL
    switch (signalnum) {
        /* Though being a UNIX, HP-UX does not provide strsignal(3). */
#ifndef MS_WINDOWS
        case SIGHUP:
            res = "Hangup";
            break;
        case SIGALRM:
            res = "Alarm clock";
            break;
        case SIGPIPE:
            res = "Broken pipe";
            break;
        case SIGQUIT:
            res = "Quit";
            break;
        case SIGCHLD:
            res = "Child exited";
            break;
#endif
        /* Custom redefinition of POSIX signals allowed on Windows. */
        case SIGINT:
            res = "Interrupt";
            break;
        case SIGILL:
            res = "Illegal instruction";
            break;
        case SIGABRT:
            res = "Aborted";
            break;
        case SIGFPE:
            res = "Floating-point exception";
            break;
        case SIGSEGV:
            res = "Segmentation fault";
            break;
        case SIGTERM:
            res = "Terminated";
            break;
        default:
            Py_RETURN_NONE;
    }
#else
    errno = 0;
    res = strsignal(signalnum);

    if (errno || res == NULL || strstr(res, "Unknown signal") != NULL)
        Py_RETURN_NONE;
#endif

    return TyUnicode_FromString(res);
}

#ifdef HAVE_SIGINTERRUPT

/*[clinic input]
signal.siginterrupt

    signalnum: int
    flag:      int
    /

Change system call restart behaviour.

If flag is False, system calls will be restarted when interrupted by
signal sig, else system calls will be interrupted.
[clinic start generated code]*/

static TyObject *
signal_siginterrupt_impl(TyObject *module, int signalnum, int flag)
/*[clinic end generated code: output=063816243d85dd19 input=4160acacca3e2099]*/
{
    if (signalnum < 1 || signalnum >= Ty_NSIG) {
        TyErr_SetString(TyExc_ValueError,
                        "signal number out of range");
        return NULL;
    }
#ifdef HAVE_SIGACTION
    struct sigaction act;
    (void) sigaction(signalnum, NULL, &act);
    if (flag) {
        act.sa_flags &= ~SA_RESTART;
    }
    else {
        act.sa_flags |= SA_RESTART;
    }
    if (sigaction(signalnum, &act, NULL) < 0) {
#else
    if (siginterrupt(signalnum, flag) < 0) {
#endif
        TyErr_SetFromErrno(TyExc_OSError);
        return NULL;
    }
    Py_RETURN_NONE;
}

#endif


/*[clinic input]
signal.set_wakeup_fd

    fd as fdobj: object
    /
    *
    warn_on_full_buffer: bool = True

Sets the fd to be written to (with the signal number) when a signal comes in.

A library can use this to wakeup select or poll.
The previous fd or -1 is returned.

The fd must be non-blocking.
[clinic start generated code]*/

static TyObject *
signal_set_wakeup_fd_impl(TyObject *module, TyObject *fdobj,
                          int warn_on_full_buffer)
/*[clinic end generated code: output=2280d72dd2a54c4f input=5b545946a28b8339]*/
{
    struct _Ty_stat_struct status;
#ifdef MS_WINDOWS
    SOCKET_T sockfd, old_sockfd;
    int res;
    int res_size = sizeof res;
    TyObject *mod;
    int is_socket;

    sockfd = TyLong_AsSocket_t(fdobj);
    if (sockfd == (SOCKET_T)(-1) && TyErr_Occurred())
        return NULL;
#else
    int fd = TyLong_AsInt(fdobj);
    if (fd == -1 && TyErr_Occurred()) {
        return NULL;
    }
#endif

    TyThreadState *tstate = _TyThreadState_GET();
    if (!_Ty_ThreadCanHandleSignals(tstate->interp)) {
        _TyErr_SetString(tstate, TyExc_ValueError,
                         "set_wakeup_fd only works in main thread "
                         "of the main interpreter");
        return NULL;
    }

#ifdef MS_WINDOWS
    is_socket = 0;
    if (sockfd != INVALID_FD) {
        /* Import the _socket module to call WSAStartup() */
        mod = TyImport_ImportModule("_socket");
        if (mod == NULL)
            return NULL;
        Ty_DECREF(mod);

        /* test the socket */
        if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR,
                       (char *)&res, &res_size) != 0) {
            int fd, err;

            err = WSAGetLastError();
            if (err != WSAENOTSOCK) {
                TyErr_SetExcFromWindowsErr(TyExc_OSError, err);
                return NULL;
            }

            fd = (int)sockfd;
            if ((SOCKET_T)fd != sockfd) {
                _TyErr_SetString(tstate, TyExc_ValueError, "invalid fd");
                return NULL;
            }

            if (_Ty_fstat(fd, &status) != 0) {
                return NULL;
            }

            /* on Windows, a file cannot be set to non-blocking mode */
        }
        else {
            is_socket = 1;

            /* Windows does not provide a function to test if a socket
               is in non-blocking mode */
        }
    }

    old_sockfd = wakeup.fd;
    wakeup.fd = Ty_SAFE_DOWNCAST(sockfd, SOCKET_T, int);
    wakeup.warn_on_full_buffer = warn_on_full_buffer;
    wakeup.use_send = is_socket;

    if (old_sockfd != INVALID_FD)
        return TyLong_FromSocket_t(old_sockfd);
    else
        return TyLong_FromLong(-1);
#else
    if (fd != -1) {
        int blocking;

        if (_Ty_fstat(fd, &status) != 0)
            return NULL;

        blocking = _Ty_get_blocking(fd);
        if (blocking < 0)
            return NULL;
        if (blocking) {
            _TyErr_Format(tstate, TyExc_ValueError,
                          "the fd %i must be in non-blocking mode",
                          fd);
            return NULL;
        }
    }

    int old_fd = wakeup.fd;
    wakeup.fd = fd;
    wakeup.warn_on_full_buffer = warn_on_full_buffer;

    return TyLong_FromLong(old_fd);
#endif
}

/* C API for the same, without all the error checking */
int
PySignal_SetWakeupFd(int fd)
{
    if (fd < 0) {
        fd = -1;
    }

    int old_fd = wakeup.fd;
    wakeup.fd = fd;
    wakeup.warn_on_full_buffer = 1;
    return old_fd;
}


#ifdef HAVE_SETITIMER
/*[clinic input]
signal.setitimer

    which:    int
    seconds:  object
    interval: object(c_default="NULL") = 0.0
    /

Sets given itimer (one of ITIMER_REAL, ITIMER_VIRTUAL or ITIMER_PROF).

The timer will fire after value seconds and after that every interval seconds.
The itimer can be cleared by setting seconds to zero.

Returns old values as a tuple: (delay, interval).
[clinic start generated code]*/

static TyObject *
signal_setitimer_impl(TyObject *module, int which, TyObject *seconds,
                      TyObject *interval)
/*[clinic end generated code: output=65f9dcbddc35527b input=de43daf194e6f66f]*/
{
    _signal_module_state *modstate = get_signal_state(module);

    struct itimerval new;
    if (timeval_from_double(seconds, &new.it_value) < 0) {
        return NULL;
    }
    if (timeval_from_double(interval, &new.it_interval) < 0) {
        return NULL;
    }

    /* Let OS check "which" value */
    struct itimerval old;
    if (setitimer(which, &new, &old) != 0) {
        TyErr_SetFromErrno(modstate->itimer_error);
        return NULL;
    }

    return itimer_retval(&old);
}
#endif  // HAVE_SETITIMER


#ifdef HAVE_GETITIMER
/*[clinic input]
signal.getitimer

    which:    int
    /

Returns current value of given itimer.
[clinic start generated code]*/

static TyObject *
signal_getitimer_impl(TyObject *module, int which)
/*[clinic end generated code: output=9e053175d517db40 input=f7d21d38f3490627]*/
{
    _signal_module_state *modstate = get_signal_state(module);

    struct itimerval old;
    if (getitimer(which, &old) != 0) {
        TyErr_SetFromErrno(modstate->itimer_error);
        return NULL;
    }

    return itimer_retval(&old);
}
#endif // HAVE_GETITIMER


#ifdef HAVE_SIGSET_T
#if defined(PYPTHREAD_SIGMASK) || defined(HAVE_SIGPENDING)
static TyObject*
sigset_to_set(sigset_t mask)
{
    TyObject *signum, *result;
    int sig;

    result = TySet_New(0);
    if (result == NULL)
        return NULL;

    for (sig = 1; sig < Ty_NSIG; sig++) {
        if (sigismember(&mask, sig) != 1)
            continue;

        /* Handle the case where it is a member by adding the signal to
           the result list.  Ignore the other cases because they mean the
           signal isn't a member of the mask or the signal was invalid,
           and an invalid signal must have been our fault in constructing
           the loop boundaries. */
        signum = TyLong_FromLong(sig);
        if (signum == NULL) {
            Ty_DECREF(result);
            return NULL;
        }
        if (TySet_Add(result, signum) == -1) {
            Ty_DECREF(signum);
            Ty_DECREF(result);
            return NULL;
        }
        Ty_DECREF(signum);
    }
    return result;
}
#endif

#ifdef PYPTHREAD_SIGMASK

/*[clinic input]
signal.pthread_sigmask

    how:  int
    mask: sigset_t
    /

Fetch and/or change the signal mask of the calling thread.
[clinic start generated code]*/

static TyObject *
signal_pthread_sigmask_impl(TyObject *module, int how, sigset_t mask)
/*[clinic end generated code: output=0562c0fb192981a8 input=85bcebda442fa77f]*/
{
    sigset_t previous;
    int err;

    err = pthread_sigmask(how, &mask, &previous);
    if (err != 0) {
        errno = err;
        TyErr_SetFromErrno(TyExc_OSError);
        return NULL;
    }

    /* if signals was unblocked, signal handlers have been called */
    if (TyErr_CheckSignals())
        return NULL;

    return sigset_to_set(previous);
}

#endif   /* #ifdef PYPTHREAD_SIGMASK */


#ifdef HAVE_SIGPENDING

/*[clinic input]
signal.sigpending

Examine pending signals.

Returns a set of signal numbers that are pending for delivery to
the calling thread.
[clinic start generated code]*/

static TyObject *
signal_sigpending_impl(TyObject *module)
/*[clinic end generated code: output=53375ffe89325022 input=e0036c016f874e29]*/
{
    int err;
    sigset_t mask;
    err = sigpending(&mask);
    if (err)
        return TyErr_SetFromErrno(TyExc_OSError);
    return sigset_to_set(mask);
}

#endif   /* #ifdef HAVE_SIGPENDING */


#ifdef HAVE_SIGWAIT

/*[clinic input]
signal.sigwait

    sigset: sigset_t
    /

Wait for a signal.

Suspend execution of the calling thread until the delivery of one of the
signals specified in the signal set sigset.  The function accepts the signal
and returns the signal number.
[clinic start generated code]*/

static TyObject *
signal_sigwait_impl(TyObject *module, sigset_t sigset)
/*[clinic end generated code: output=f43770699d682f96 input=a6fbd47b1086d119]*/
{
    int err, signum;

    Ty_BEGIN_ALLOW_THREADS
    err = sigwait(&sigset, &signum);
    Ty_END_ALLOW_THREADS
    if (err) {
        errno = err;
        return TyErr_SetFromErrno(TyExc_OSError);
    }

    return TyLong_FromLong(signum);
}

#endif   /* #ifdef HAVE_SIGWAIT */
#endif   /* #ifdef HAVE_SIGSET_T */

#if (defined(HAVE_SIGFILLSET) && defined(HAVE_SIGSET_T)) || defined(MS_WINDOWS)

/*[clinic input]
signal.valid_signals

Return a set of valid signal numbers on this platform.

The signal numbers returned by this function can be safely passed to
functions like `pthread_sigmask`.
[clinic start generated code]*/

static TyObject *
signal_valid_signals_impl(TyObject *module)
/*[clinic end generated code: output=1609cffbcfcf1314 input=86a3717ff25288f2]*/
{
#ifdef MS_WINDOWS
#ifdef SIGBREAK
    TyObject *tup = Ty_BuildValue("(iiiiiii)", SIGABRT, SIGBREAK, SIGFPE,
                                  SIGILL, SIGINT, SIGSEGV, SIGTERM);
#else
    TyObject *tup = Ty_BuildValue("(iiiiii)", SIGABRT, SIGFPE, SIGILL,
                                  SIGINT, SIGSEGV, SIGTERM);
#endif
    if (tup == NULL) {
        return NULL;
    }
    TyObject *set = TySet_New(tup);
    Ty_DECREF(tup);
    return set;
#else
    sigset_t mask;
    if (sigemptyset(&mask) || sigfillset(&mask)) {
        return TyErr_SetFromErrno(TyExc_OSError);
    }
    return sigset_to_set(mask);
#endif
}

#endif   /* #if (defined(HAVE_SIGFILLSET) && defined(HAVE_SIGSET_T)) || defined(MS_WINDOWS) */



#if defined(HAVE_SIGWAITINFO) || defined(HAVE_SIGTIMEDWAIT)
static TyStructSequence_Field struct_siginfo_fields[] = {
    {"si_signo",        "signal number"},
    {"si_code",         "signal code"},
    {"si_errno",        "errno associated with this signal"},
    {"si_pid",          "sending process ID"},
    {"si_uid",          "real user ID of sending process"},
    {"si_status",       "exit value or signal"},
    {"si_band",         "band event for SIGPOLL"},
    {0}
};

TyDoc_STRVAR(struct_siginfo__doc__,
"struct_siginfo: Result from sigwaitinfo or sigtimedwait.\n\n\
This object may be accessed either as a tuple of\n\
(si_signo, si_code, si_errno, si_pid, si_uid, si_status, si_band),\n\
or via the attributes si_signo, si_code, and so on.");

static TyStructSequence_Desc struct_siginfo_desc = {
    "signal.struct_siginfo",           /* name */
    struct_siginfo__doc__,       /* doc */
    struct_siginfo_fields,       /* fields */
    7          /* n_in_sequence */
};


static TyObject *
fill_siginfo(_signal_module_state *state, siginfo_t *si)
{
    TyObject *result = TyStructSequence_New(state->siginfo_type);
    if (!result)
        return NULL;

    TyStructSequence_SET_ITEM(result, 0, TyLong_FromLong((long)(si->si_signo)));
    TyStructSequence_SET_ITEM(result, 1, TyLong_FromLong((long)(si->si_code)));
#ifdef __VXWORKS__
    TyStructSequence_SET_ITEM(result, 2, TyLong_FromLong(0L));
    TyStructSequence_SET_ITEM(result, 3, TyLong_FromLong(0L));
    TyStructSequence_SET_ITEM(result, 4, TyLong_FromLong(0L));
    TyStructSequence_SET_ITEM(result, 5, TyLong_FromLong(0L));
#else
    TyStructSequence_SET_ITEM(result, 2, TyLong_FromLong((long)(si->si_errno)));
    TyStructSequence_SET_ITEM(result, 3, TyLong_FromPid(si->si_pid));
    TyStructSequence_SET_ITEM(result, 4, _TyLong_FromUid(si->si_uid));
    TyStructSequence_SET_ITEM(result, 5,
                                TyLong_FromLong((long)(si->si_status)));
#endif
#ifdef HAVE_SIGINFO_T_SI_BAND
    TyStructSequence_SET_ITEM(result, 6, TyLong_FromLong(si->si_band));
#else
    TyStructSequence_SET_ITEM(result, 6, TyLong_FromLong(0L));
#endif
    if (TyErr_Occurred()) {
        Ty_DECREF(result);
        return NULL;
    }

    return result;
}
#endif

#ifdef HAVE_SIGSET_T
#ifdef HAVE_SIGWAITINFO

/*[clinic input]
signal.sigwaitinfo

    sigset: sigset_t
    /

Wait synchronously until one of the signals in *sigset* is delivered.

Returns a struct_siginfo containing information about the signal.
[clinic start generated code]*/

static TyObject *
signal_sigwaitinfo_impl(TyObject *module, sigset_t sigset)
/*[clinic end generated code: output=1eb2f1fa236fdbca input=3d1a7e1f27fc664c]*/
{
    siginfo_t si;
    int err;
    int async_err = 0;

    do {
        Ty_BEGIN_ALLOW_THREADS
        err = sigwaitinfo(&sigset, &si);
        Ty_END_ALLOW_THREADS
    } while (err == -1
             && errno == EINTR && !(async_err = TyErr_CheckSignals()));
    if (err == -1)
        return (!async_err) ? TyErr_SetFromErrno(TyExc_OSError) : NULL;

    _signal_module_state *state = get_signal_state(module);
    return fill_siginfo(state, &si);
}

#endif   /* #ifdef HAVE_SIGWAITINFO */

#ifdef HAVE_SIGTIMEDWAIT

/*[clinic input]
signal.sigtimedwait

    sigset: sigset_t
    timeout as timeout_obj: object
    /

Like sigwaitinfo(), but with a timeout.

The timeout is specified in seconds, with floating-point numbers allowed.
[clinic start generated code]*/

static TyObject *
signal_sigtimedwait_impl(TyObject *module, sigset_t sigset,
                         TyObject *timeout_obj)
/*[clinic end generated code: output=59c8971e8ae18a64 input=955773219c1596cd]*/
{
    TyTime_t timeout;
    if (_TyTime_FromSecondsObject(&timeout,
                                  timeout_obj, _TyTime_ROUND_CEILING) < 0)
        return NULL;

    if (timeout < 0) {
        TyErr_SetString(TyExc_ValueError, "timeout must be non-negative");
        return NULL;
    }

    TyTime_t deadline = _PyDeadline_Init(timeout);
    siginfo_t si;

    do {
        struct timespec ts;
        if (_TyTime_AsTimespec(timeout, &ts) < 0) {
            return NULL;
        }

        int res;
        Ty_BEGIN_ALLOW_THREADS
        res = sigtimedwait(&sigset, &si, &ts);
        Ty_END_ALLOW_THREADS

        if (res != -1)
            break;

        if (errno != EINTR) {
            if (errno == EAGAIN)
                Py_RETURN_NONE;
            else
                return TyErr_SetFromErrno(TyExc_OSError);
        }

        /* sigtimedwait() was interrupted by a signal (EINTR) */
        if (TyErr_CheckSignals())
            return NULL;

        timeout = _PyDeadline_Get(deadline);
        if (timeout < 0) {
            break;
        }
    } while (1);

    _signal_module_state *state = get_signal_state(module);
    return fill_siginfo(state, &si);
}

#endif   /* #ifdef HAVE_SIGTIMEDWAIT */
#endif   /* #ifdef HAVE_SIGSET_T */


#if defined(HAVE_PTHREAD_KILL)

/*[clinic input]
signal.pthread_kill

    thread_id:  unsigned_long(bitwise=True)
    signalnum:  int
    /

Send a signal to a thread.
[clinic start generated code]*/

static TyObject *
signal_pthread_kill_impl(TyObject *module, unsigned long thread_id,
                         int signalnum)
/*[clinic end generated code: output=7629919b791bc27f input=1d901f2c7bb544ff]*/
{
    int err;

    if (TySys_Audit("signal.pthread_kill", "ki", thread_id, signalnum) < 0) {
        return NULL;
    }

    err = pthread_kill((pthread_t)thread_id, signalnum);
    if (err != 0) {
        errno = err;
        TyErr_SetFromErrno(TyExc_OSError);
        return NULL;
    }

    /* the signal may have been send to the current thread */
    if (TyErr_CheckSignals())
        return NULL;

    Py_RETURN_NONE;
}

#endif   /* #if defined(HAVE_PTHREAD_KILL) */


// This system call always crashes on older Android versions.
#if defined(__linux__) && defined(__NR_pidfd_send_signal) && \
    !(defined(__ANDROID__) && __ANDROID_API__ < 31)
/*[clinic input]
signal.pidfd_send_signal

    pidfd: int
    signalnum: int
    siginfo: object = None
    flags: int = 0
    /

Send a signal to a process referred to by a pid file descriptor.
[clinic start generated code]*/

static TyObject *
signal_pidfd_send_signal_impl(TyObject *module, int pidfd, int signalnum,
                              TyObject *siginfo, int flags)
/*[clinic end generated code: output=2d59f04a75d9cbdf input=2a6543a1f4ac2000]*/

{
    if (siginfo != Ty_None) {
        TyErr_SetString(TyExc_TypeError, "siginfo must be None");
        return NULL;
    }
    if (syscall(__NR_pidfd_send_signal, pidfd, signalnum, NULL, flags) < 0) {
        TyErr_SetFromErrno(TyExc_OSError);
        return NULL;
    }
    Py_RETURN_NONE;
}
#endif



/* List of functions defined in the module -- some of the methoddefs are
   defined to nothing if the corresponding C function is not available. */
static TyMethodDef signal_methods[] = {
    SIGNAL_DEFAULT_INT_HANDLER_METHODDEF
    SIGNAL_ALARM_METHODDEF
    SIGNAL_SETITIMER_METHODDEF
    SIGNAL_GETITIMER_METHODDEF
    SIGNAL_SIGNAL_METHODDEF
    SIGNAL_RAISE_SIGNAL_METHODDEF
    SIGNAL_STRSIGNAL_METHODDEF
    SIGNAL_GETSIGNAL_METHODDEF
    SIGNAL_SET_WAKEUP_FD_METHODDEF
    SIGNAL_SIGINTERRUPT_METHODDEF
    SIGNAL_PAUSE_METHODDEF
    SIGNAL_PIDFD_SEND_SIGNAL_METHODDEF
    SIGNAL_PTHREAD_KILL_METHODDEF
    SIGNAL_PTHREAD_SIGMASK_METHODDEF
    SIGNAL_SIGPENDING_METHODDEF
    SIGNAL_SIGWAIT_METHODDEF
    SIGNAL_SIGWAITINFO_METHODDEF
    SIGNAL_SIGTIMEDWAIT_METHODDEF
#if defined(HAVE_SIGFILLSET) || defined(MS_WINDOWS)
    SIGNAL_VALID_SIGNALS_METHODDEF
#endif
    {NULL, NULL}           /* sentinel */
};


TyDoc_STRVAR(module_doc,
"This module provides mechanisms to use signal handlers in Python.\n\
\n\
Functions:\n\
\n\
alarm() -- cause SIGALRM after a specified time [Unix only]\n\
setitimer() -- cause a signal (described below) after a specified\n\
               float time and the timer may restart then [Unix only]\n\
getitimer() -- get current value of timer [Unix only]\n\
signal() -- set the action for a given signal\n\
getsignal() -- get the signal action for a given signal\n\
pause() -- wait until a signal arrives [Unix only]\n\
default_int_handler() -- default SIGINT handler\n\
\n\
signal constants:\n\
SIG_DFL -- used to refer to the system default handler\n\
SIG_IGN -- used to ignore the signal\n\
NSIG -- number of defined signals\n\
SIGINT, SIGTERM, etc. -- signal numbers\n\
\n\
itimer constants:\n\
ITIMER_REAL -- decrements in real time, and delivers SIGALRM upon\n\
               expiration\n\
ITIMER_VIRTUAL -- decrements only when the process is executing,\n\
               and delivers SIGVTALRM upon expiration\n\
ITIMER_PROF -- decrements both when the process is executing and\n\
               when the system is executing on behalf of the process.\n\
               Coupled with ITIMER_VIRTUAL, this timer is usually\n\
               used to profile the time spent by the application\n\
               in user and kernel space. SIGPROF is delivered upon\n\
               expiration.\n\
\n\n\
*** IMPORTANT NOTICE ***\n\
A signal handler function is called with two arguments:\n\
the first is the signal number, the second is the interrupted stack frame.");



static int
signal_add_constants(TyObject *module)
{
    if (TyModule_AddIntConstant(module, "NSIG", Ty_NSIG) < 0) {
        return -1;
    }

#define ADD_INT_MACRO(macro) \
    if (TyModule_AddIntConstant(module, #macro, macro) < 0) { \
        return -1; \
    }

    // SIG_xxx pthread_sigmask() constants
#ifdef SIG_BLOCK
    ADD_INT_MACRO(SIG_BLOCK);
#endif
#ifdef SIG_UNBLOCK
    ADD_INT_MACRO(SIG_UNBLOCK);
#endif
#ifdef SIG_SETMASK
    ADD_INT_MACRO(SIG_SETMASK);
#endif

    // SIGxxx signal number constants
#ifdef SIGHUP
    ADD_INT_MACRO(SIGHUP);
#endif
#ifdef SIGINT
    ADD_INT_MACRO(SIGINT);
#endif
#ifdef SIGBREAK
    ADD_INT_MACRO(SIGBREAK);
#endif
#ifdef SIGQUIT
    ADD_INT_MACRO(SIGQUIT);
#endif
#ifdef SIGILL
    ADD_INT_MACRO(SIGILL);
#endif
#ifdef SIGTRAP
    ADD_INT_MACRO(SIGTRAP);
#endif
#ifdef SIGIOT
    ADD_INT_MACRO(SIGIOT);
#endif
#ifdef SIGABRT
    ADD_INT_MACRO(SIGABRT);
#endif
#ifdef SIGEMT
    ADD_INT_MACRO(SIGEMT);
#endif
#ifdef SIGFPE
    ADD_INT_MACRO(SIGFPE);
#endif
#ifdef SIGKILL
    ADD_INT_MACRO(SIGKILL);
#endif
#ifdef SIGBUS
    ADD_INT_MACRO(SIGBUS);
#endif
#ifdef SIGSEGV
    ADD_INT_MACRO(SIGSEGV);
#endif
#ifdef SIGSYS
    ADD_INT_MACRO(SIGSYS);
#endif
#ifdef SIGPIPE
    ADD_INT_MACRO(SIGPIPE);
#endif
#ifdef SIGALRM
    ADD_INT_MACRO(SIGALRM);
#endif
#ifdef SIGTERM
    ADD_INT_MACRO(SIGTERM);
#endif
#ifdef SIGUSR1
    ADD_INT_MACRO(SIGUSR1);
#endif
#ifdef SIGUSR2
    ADD_INT_MACRO(SIGUSR2);
#endif
#ifdef SIGCLD
    ADD_INT_MACRO(SIGCLD);
#endif
#ifdef SIGCHLD
    ADD_INT_MACRO(SIGCHLD);
#endif
#ifdef SIGPWR
    ADD_INT_MACRO(SIGPWR);
#endif
#ifdef SIGIO
    ADD_INT_MACRO(SIGIO);
#endif
#ifdef SIGURG
    ADD_INT_MACRO(SIGURG);
#endif
#ifdef SIGWINCH
    ADD_INT_MACRO(SIGWINCH);
#endif
#ifdef SIGPOLL
    ADD_INT_MACRO(SIGPOLL);
#endif
#ifdef SIGSTOP
    ADD_INT_MACRO(SIGSTOP);
#endif
#ifdef SIGTSTP
    ADD_INT_MACRO(SIGTSTP);
#endif
#ifdef SIGCONT
    ADD_INT_MACRO(SIGCONT);
#endif
#ifdef SIGTTIN
    ADD_INT_MACRO(SIGTTIN);
#endif
#ifdef SIGTTOU
    ADD_INT_MACRO(SIGTTOU);
#endif
#ifdef SIGVTALRM
    ADD_INT_MACRO(SIGVTALRM);
#endif
#ifdef SIGPROF
    ADD_INT_MACRO(SIGPROF);
#endif
#ifdef SIGXCPU
    ADD_INT_MACRO(SIGXCPU);
#endif
#ifdef SIGXFSZ
    ADD_INT_MACRO(SIGXFSZ);
#endif
#ifdef SIGRTMIN
    ADD_INT_MACRO(SIGRTMIN);
#endif
#ifdef SIGRTMAX
    ADD_INT_MACRO(SIGRTMAX);
#endif
#ifdef SIGINFO
    ADD_INT_MACRO(SIGINFO);
#endif
#ifdef SIGSTKFLT
    ADD_INT_MACRO(SIGSTKFLT);
#endif

    // ITIMER_xxx constants
#ifdef ITIMER_REAL
    ADD_INT_MACRO(ITIMER_REAL);
#endif
#ifdef ITIMER_VIRTUAL
    ADD_INT_MACRO(ITIMER_VIRTUAL);
#endif
#ifdef ITIMER_PROF
    ADD_INT_MACRO(ITIMER_PROF);
#endif

    // CTRL_xxx Windows signals
#ifdef CTRL_C_EVENT
    ADD_INT_MACRO(CTRL_C_EVENT);
#endif
#ifdef CTRL_BREAK_EVENT
    ADD_INT_MACRO(CTRL_BREAK_EVENT);
#endif

    return 0;

#undef ADD_INT_MACRO
}


static int
signal_get_set_handlers(signal_state_t *state, TyObject *mod_dict)
{
    // Get signal handlers
    for (int signum = 1; signum < Ty_NSIG; signum++) {
        void (*c_handler)(int) = TyOS_getsig(signum);
        TyObject *func;
        if (c_handler == SIG_DFL) {
            func = state->default_handler;
        }
        else if (c_handler == SIG_IGN) {
            func = state->ignore_handler;
        }
        else {
            func = Ty_None; // None of our business
        }
        // If signal_module_exec() is called more than one, we must
        // clear the strong reference to the previous function.
        TyObject* old_func = get_handler(signum);
        set_handler(signum, Ty_NewRef(func));
        Ty_XDECREF(old_func);
    }

    // Install Python SIGINT handler which raises KeyboardInterrupt
    TyObject* sigint_func = get_handler(SIGINT);
    if (sigint_func == state->default_handler) {
        TyObject *int_handler = PyMapping_GetItemString(mod_dict,
                                                        "default_int_handler");
        if (!int_handler) {
            return -1;
        }

        set_handler(SIGINT, int_handler);
        Ty_DECREF(sigint_func);
        TyOS_setsig(SIGINT, signal_handler);
    }
    return 0;
}


static int
signal_module_exec(TyObject *m)
{
    assert(!TyErr_Occurred());

    signal_state_t *state = &signal_global_state;
    _signal_module_state *modstate = get_signal_state(m);

    // XXX For proper isolation, these values must be guaranteed
    // to be effectively const (e.g. immortal).
    modstate->default_handler = state->default_handler;  // borrowed ref
    modstate->ignore_handler = state->ignore_handler;  // borrowed ref

#ifdef PYHAVE_ITIMER_ERROR
    modstate->itimer_error = TyErr_NewException("signal.itimer_error",
                                                TyExc_OSError, NULL);
    if (modstate->itimer_error == NULL) {
        return -1;
    }
#endif

    if (signal_add_constants(m) < 0) {
        return -1;
    }

    /* Add some symbolic constants to the module */
    TyObject *d = TyModule_GetDict(m);
    if (TyDict_SetItemString(d, "SIG_DFL", state->default_handler) < 0) {
        return -1;
    }
    if (TyDict_SetItemString(d, "SIG_IGN", state->ignore_handler) < 0) {
        return -1;
    }
#ifdef PYHAVE_ITIMER_ERROR
    if (TyDict_SetItemString(d, "ItimerError", modstate->itimer_error) < 0) {
        return -1;
    }
#endif

#if defined(HAVE_SIGWAITINFO) || defined(HAVE_SIGTIMEDWAIT)
    modstate->siginfo_type = TyStructSequence_NewType(&struct_siginfo_desc);
    if (modstate->siginfo_type == NULL) {
        return -1;
    }
#endif
#if defined(HAVE_SIGWAITINFO) || defined(HAVE_SIGTIMEDWAIT)
    if (TyModule_AddType(m, modstate->siginfo_type) < 0) {
        return -1;
    }
#endif

    TyThreadState *tstate = _TyThreadState_GET();
    if (_Ty_IsMainInterpreter(tstate->interp)) {
        if (signal_get_set_handlers(state, d) < 0) {
            return -1;
        }
    }

    assert(!TyErr_Occurred());
    return 0;
}


#ifdef PYHAVE_ITIMER_ERROR
static int
_signal_module_traverse(TyObject *module, visitproc visit, void *arg)
{
    _signal_module_state *state = get_signal_state(module);
    Ty_VISIT(state->itimer_error);
    Ty_VISIT(state->siginfo_type);
    return 0;
}

static int
_signal_module_clear(TyObject *module)
{
    _signal_module_state *state = get_signal_state(module);
    Ty_CLEAR(state->itimer_error);
    Ty_CLEAR(state->siginfo_type);
    return 0;
}

static void
_signal_module_free(void *module)
{
    _signal_module_clear((TyObject *)module);
}
#endif  // PYHAVE_ITIMER_ERROR


static PyModuleDef_Slot signal_slots[] = {
    {Ty_mod_exec, signal_module_exec},
    {Ty_mod_multiple_interpreters, Ty_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Ty_mod_gil, Ty_MOD_GIL_NOT_USED},
    {0, NULL}
};

static struct TyModuleDef signal_module = {
    PyModuleDef_HEAD_INIT,
    "_signal",
    .m_doc = module_doc,
    .m_size = sizeof(_signal_module_state),
    .m_methods = signal_methods,
    .m_slots = signal_slots,
#ifdef PYHAVE_ITIMER_ERROR
    .m_traverse = _signal_module_traverse,
    .m_clear = _signal_module_clear,
    .m_free = _signal_module_free,
#endif
};


PyMODINIT_FUNC
PyInit__signal(void)
{
    return PyModuleDef_Init(&signal_module);
}


void
_PySignal_Fini(void)
{
    signal_state_t *state = &signal_global_state;

    // Restore default signals and clear handlers
    for (int signum = 1; signum < Ty_NSIG; signum++) {
        TyObject *func = get_handler(signum);
        _Ty_atomic_store_int_relaxed(&Handlers[signum].tripped, 0);
        set_handler(signum, NULL);
        if (func != NULL
            && func != Ty_None
            && !compare_handler(func, state->default_handler)
            && !compare_handler(func, state->ignore_handler))
        {
            TyOS_setsig(signum, SIG_DFL);
        }
        Ty_XDECREF(func);
    }

#ifdef MS_WINDOWS
    if (state->sigint_event != NULL) {
        CloseHandle((HANDLE)state->sigint_event);
        state->sigint_event = NULL;
    }
#endif

    Ty_CLEAR(state->default_handler);
    Ty_CLEAR(state->ignore_handler);
}


/* Declared in pyerrors.h */
int
TyErr_CheckSignals(void)
{
    TyThreadState *tstate = _TyThreadState_GET();

    /* Opportunistically check if the GC is scheduled to run and run it
       if we have a request. This is done here because native code needs
       to call this API if is going to run for some time without executing
       Python code to ensure signals are handled. Checking for the GC here
       allows long running native code to clean cycles created using the C-API
       even if it doesn't run the evaluation loop */
    if (_Ty_eval_breaker_bit_is_set(tstate, _PY_GC_SCHEDULED_BIT)) {
        _Ty_unset_eval_breaker_bit(tstate, _PY_GC_SCHEDULED_BIT);
        _Ty_RunGC(tstate);
    }

#if defined(Ty_REMOTE_DEBUG) && defined(Ty_SUPPORTS_REMOTE_DEBUG)
    _PyRunRemoteDebugger(tstate);
#endif

    if (!_Ty_ThreadCanHandleSignals(tstate->interp)) {
        return 0;
    }

    return _TyErr_CheckSignalsTstate(tstate);
}


/* Declared in cpython/pyerrors.h */
int
_TyErr_CheckSignalsTstate(TyThreadState *tstate)
{
    _Ty_CHECK_EMSCRIPTEN_SIGNALS();
    if (!_Ty_atomic_load_int(&is_tripped)) {
        return 0;
    }

    /*
     * The is_tripped variable is meant to speed up the calls to
     * TyErr_CheckSignals (both directly or via pending calls) when no
     * signal has arrived. This variable is set to 1 when a signal arrives
     * and it is set to 0 here, when we know some signals arrived. This way
     * we can run the registered handlers with no signals blocked.
     *
     * NOTE: with this approach we can have a situation where is_tripped is
     *       1 but we have no more signals to handle (Handlers[i].tripped
     *       is 0 for every signal i). This won't do us any harm (except
     *       we're gonna spent some cycles for nothing). This happens when
     *       we receive a signal i after we zero is_tripped and before we
     *       check Handlers[i].tripped.
     */
    _Ty_atomic_store_int(&is_tripped, 0);

    _PyInterpreterFrame *frame = _TyThreadState_GetFrame(tstate);
    signal_state_t *state = &signal_global_state;
    for (int i = 1; i < Ty_NSIG; i++) {
        if (!_Ty_atomic_load_int_relaxed(&Handlers[i].tripped)) {
            continue;
        }
        _Ty_atomic_store_int_relaxed(&Handlers[i].tripped, 0);

        /* Signal handlers can be modified while a signal is received,
         * and therefore the fact that trip_signal() or TyErr_SetInterrupt()
         * was called doesn't guarantee that there is still a Python
         * signal handler for it by the time TyErr_CheckSignals() is called
         * (see bpo-43406).
         */
        TyObject *func = get_handler(i);
        if (func == NULL || func == Ty_None ||
            compare_handler(func, state->ignore_handler) ||
            compare_handler(func, state->default_handler)) {
            /* No Python signal handler due to aforementioned race condition.
             * We can't call raise() as it would break the assumption
             * that TyErr_SetInterrupt() only *simulates* an incoming
             * signal (i.e. it will never kill the process).
             * We also don't want to interrupt user code with a cryptic
             * asynchronous exception, so instead just write out an
             * unraisable error.
             */
            TyErr_Format(TyExc_OSError,
                         "Signal %i ignored due to race condition",
                         i);
            TyErr_FormatUnraisable("Exception ignored while "
                                   "calling signal handler");
            continue;
        }
        TyObject *arglist = NULL;
        if (frame == NULL) {
            arglist = Ty_BuildValue("(iO)", i, Ty_None);
        }
        else {
            PyFrameObject *f = _TyFrame_GetFrameObject(frame);
            if (f != NULL) {
                arglist = Ty_BuildValue("(iO)", i, f);
            }
        }
        TyObject *result;
        if (arglist) {
            result = _TyObject_Call(tstate, func, arglist, NULL);
            Ty_DECREF(arglist);
        }
        else {
            result = NULL;
        }
        if (!result) {
            /* On error, re-schedule a call to _TyErr_CheckSignalsTstate() */
            _Ty_atomic_store_int(&is_tripped, 1);
            return -1;
        }

        Ty_DECREF(result);
    }

    return 0;
}



int
_TyErr_CheckSignals(void)
{
    TyThreadState *tstate = _TyThreadState_GET();
    return _TyErr_CheckSignalsTstate(tstate);
}


/* Simulate the effect of a signal arriving. The next time TyErr_CheckSignals
   is called,  the corresponding Python signal handler will be raised.

   Missing signal handler for the given signal number is silently ignored. */
int
TyErr_SetInterruptEx(int signum)
{
    if (signum < 1 || signum >= Ty_NSIG) {
        return -1;
    }

    signal_state_t *state = &signal_global_state;
    TyObject *func = get_handler(signum);
    if (!compare_handler(func, state->ignore_handler)
            && !compare_handler(func, state->default_handler)) {
        trip_signal(signum);
    }
    return 0;
}

void
TyErr_SetInterrupt(void)
{
    (void) TyErr_SetInterruptEx(SIGINT);
}

static int
signal_install_handlers(void)
{
#ifdef SIGPIPE
    TyOS_setsig(SIGPIPE, SIG_IGN);
#endif
#ifdef SIGXFZ
    TyOS_setsig(SIGXFZ, SIG_IGN);
#endif
#ifdef SIGXFSZ
    TyOS_setsig(SIGXFSZ, SIG_IGN);
#endif

    // Import _signal to install the Python SIGINT handler
    TyObject *module = TyImport_ImportModule("_signal");
    if (!module) {
        return -1;
    }
    Ty_DECREF(module);

    return 0;
}


/* Restore signals that the interpreter has called SIG_IGN on to SIG_DFL.
 *
 * All of the code in this function must only use async-signal-safe functions,
 * listed at `man 7 signal` or
 * http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_04.html.
 *
 * If this function is updated, update also _posix_spawn() of subprocess.py.
 */
void
_Ty_RestoreSignals(void)
{
#ifdef SIGPIPE
    TyOS_setsig(SIGPIPE, SIG_DFL);
#endif
#ifdef SIGXFZ
    TyOS_setsig(SIGXFZ, SIG_DFL);
#endif
#ifdef SIGXFSZ
    TyOS_setsig(SIGXFSZ, SIG_DFL);
#endif
}


int
_PySignal_Init(int install_signal_handlers)
{
    signal_state_t *state = &signal_global_state;

    state->default_handler = TyLong_FromVoidPtr((void *)SIG_DFL);
    if (state->default_handler == NULL) {
        return -1;
    }

    state->ignore_handler = TyLong_FromVoidPtr((void *)SIG_IGN);
    if (state->ignore_handler == NULL) {
        return -1;
    }

#ifdef MS_WINDOWS
    /* Create manual-reset event, initially unset */
    state->sigint_event = (void *)CreateEvent(NULL, TRUE, FALSE, FALSE);
    if (state->sigint_event == NULL) {
        TyErr_SetFromWindowsErr(0);
        return -1;
    }
#endif

    for (int signum = 1; signum < Ty_NSIG; signum++) {
        _Ty_atomic_store_int_relaxed(&Handlers[signum].tripped, 0);
    }

    if (install_signal_handlers) {
        if (signal_install_handlers() < 0) {
            return -1;
        }
    }

    return 0;
}


// The caller doesn't have to hold the GIL
int
_TyOS_InterruptOccurred(TyThreadState *tstate)
{
    _Ty_EnsureTstateNotNULL(tstate);
    if (!_Ty_ThreadCanHandleSignals(tstate->interp)) {
        return 0;
    }

    if (!_Ty_atomic_load_int_relaxed(&Handlers[SIGINT].tripped)) {
        return 0;
    }

    _Ty_atomic_store_int_relaxed(&Handlers[SIGINT].tripped, 0);
    return 1;
}


// The caller must to hold the GIL
int
TyOS_InterruptOccurred(void)
{
    TyThreadState *tstate = _TyThreadState_GET();
    return _TyOS_InterruptOccurred(tstate);
}


#ifdef HAVE_FORK
static void
_clear_pending_signals(void)
{
    if (!_Ty_atomic_load_int(&is_tripped)) {
        return;
    }

    _Ty_atomic_store_int(&is_tripped, 0);
    for (int i = 1; i < Ty_NSIG; ++i) {
        _Ty_atomic_store_int_relaxed(&Handlers[i].tripped, 0);
    }
}

void
_PySignal_AfterFork(void)
{
    /* Clear the signal flags after forking so that they aren't handled
     * in both processes if they came in just before the fork() but before
     * the interpreter had an opportunity to call the handlers.  issue9535. */
    _clear_pending_signals();
}
#endif   /* HAVE_FORK */


int
_TyOS_IsMainThread(void)
{
    TyInterpreterState *interp = _TyInterpreterState_GET();
    return _Ty_ThreadCanHandleSignals(interp);
}

#ifdef MS_WINDOWS
/* Returns a manual-reset event which gets tripped whenever
   SIGINT is received.

   Python.h does not include windows.h so we do cannot use HANDLE
   as the return type of this function.  We use void* instead. */
void *_TyOS_SigintEvent(void)
{
    signal_state_t *state = &signal_global_state;
    return state->sigint_event;
}
#endif
