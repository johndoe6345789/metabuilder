================================================================================
HTTP/API UTILITIES - DETAILED COMPARISON & DECISION MATRIX
Generated: 2026-01-23
================================================================================

QUICK COMPARISON: Native Fetch vs Redux Async vs TanStack Query vs Axios vs SWR

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Category                â”‚ Fetch        â”‚ Redux Async â”‚ TanStackâ”‚ Axios  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ BUNDLE SIZE (gzipped)   â”‚ 0 KB         â”‚ <10 KB      â”‚ 43.8 KB â”‚ 18.4KB â”‚
â”‚ SETUP COMPLEXITY        â”‚ Minimal      â”‚ Medium      â”‚ Complex â”‚ Low    â”‚
â”‚ LEARNING CURVE          â”‚ Very Low     â”‚ Low         â”‚ Medium  â”‚ Low    â”‚
â”‚ STATE MANAGEMENT        â”‚ Manual       â”‚ Redux-based â”‚ Internalâ”‚ Manual â”‚
â”‚ HTTP METHODS            â”‚ âœ… All       â”‚ âœ… All      â”‚ âœ… All  â”‚ âœ… All â”‚
â”‚ RETRIES                 â”‚ âŒ Manual    â”‚ âœ… Auto     â”‚ âœ… Auto â”‚ âŒ Addonâ”‚
â”‚ REQUEST DEDUP           â”‚ âŒ Manual    â”‚ âœ… Auto     â”‚ âœ… Auto â”‚ âŒ No  â”‚
â”‚ CACHING                 â”‚ âŒ No        â”‚ âœ… Manual   â”‚ âœ… Auto â”‚ âŒ No  â”‚
â”‚ PAGINATION              â”‚ âŒ No        â”‚ âŒ Custom   â”‚ âœ… Builtâ”‚ âŒ No  â”‚
â”‚ INFINITE QUERIES        â”‚ âŒ No        â”‚ âŒ No       â”‚ âœ… Builtâ”‚ âŒ No  â”‚
â”‚ OPTIMISTIC UPDATES      â”‚ âŒ No        â”‚ âŒ No       â”‚ âœ… Yes  â”‚ âŒ No  â”‚
â”‚ ERROR HANDLING          â”‚ âš ï¸ Manual    â”‚ âœ… Built-in â”‚ âœ… Auto â”‚ âœ… Autoâ”‚
â”‚ TYPESCRIPT SUPPORT      â”‚ âœ… Excellent â”‚ âœ… Excel    â”‚ âœ… Excelâ”‚ âœ… Goodâ”‚
â”‚ DEVTOOLS INTEGRATION    â”‚ âŒ No        â”‚ âœ… Redux    â”‚ âœ… TRQ  â”‚ âŒ No  â”‚
â”‚ MULTI-TENANT FILTERING  â”‚ âš ï¸ Manual    â”‚ âœ… Enforced â”‚ âš ï¸ Manualâ”‚âš ï¸Manualâ”‚
â”‚ RATE LIMITING           â”‚ âš ï¸ Manual    â”‚ âœ… Manual   â”‚ âš ï¸ Manualâ”‚ âœ… Autoâ”‚
â”‚ BROWSER SUPPORT         â”‚ All modern   â”‚ All modern  â”‚ All     â”‚ All    â”‚
â”‚ NODE.JS SUPPORT         â”‚ âœ… v18+      â”‚ âœ… v16+     â”‚ âœ… Any  â”‚ âœ… Any â”‚
â”‚ DOCUMENTATION           â”‚ MDN (great)  â”‚ Internal    â”‚ Excellentâ”‚ Good  â”‚
â”‚ COMMUNITY ADOPTION      â”‚ 100% (native)â”‚ Low (new)   â”‚ Very Highâ”‚ High  â”‚
â”‚ PRODUCTION READY        â”‚ âœ… Yes       â”‚ âœ… Yes      â”‚ âœ… Yes  â”‚ âœ… Yes â”‚
â”‚ METABUILDER STATUS      â”‚ âœ… In use    â”‚ âœ… In use   â”‚ âŒ None â”‚ âš ï¸ 1pkgâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜


USE CASE MATRIX - Which to Choose?

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Scenario                           â”‚ Recommended  â”‚ Acceptableâ”‚ Avoid    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Simple GET request                 â”‚ Fetch        â”‚ Redux    â”‚ TanStack â”‚
â”‚ With retry/reload logic            â”‚ Redux Async  â”‚ Fetch    â”‚ Axios    â”‚
â”‚ Complex async state management     â”‚ Redux Async  â”‚ Fetch    â”‚ TanStack*â”‚
â”‚ Paginated API responses            â”‚ Redux Custom â”‚ Fetch    â”‚ TanStack â”‚
â”‚ Infinite scroll lists              â”‚ âŒ Redux     â”‚ âŒ Fetch â”‚ TanStack â”‚
â”‚ Real-time WebSocket updates        â”‚ Redux+WS    â”‚ Fetch+WS â”‚ None     â”‚
â”‚ Server-side rendering (Next.js)    â”‚ Fetch        â”‚ Fetch    â”‚ Redux    â”‚
â”‚ Multi-tenant filtering required    â”‚ Redux Async  â”‚ Fetch    â”‚ Any      â”‚
â”‚ Rate limited endpoints             â”‚ Redux Async  â”‚ Fetch    â”‚ Axios    â”‚
â”‚ File uploads                       â”‚ Fetch FormDataâ”‚ Axios   â”‚ Redux    â”‚
â”‚ Authentication headers             â”‚ Fetch headersâ”‚ Redux    â”‚ Axios    â”‚
â”‚ GraphQL queries                    â”‚ Custom       â”‚ TanStack â”‚ None     â”‚
â”‚ Offline-first app                 â”‚ TanStack     â”‚ Redux    â”‚ Fetch    â”‚
â”‚ Minimal bundle size (<50KB total)  â”‚ Fetch        â”‚ Redux    â”‚ TanStack â”‚
â”‚ Observable state (DevTools)        â”‚ Redux        â”‚ TanStack â”‚ Fetch    â”‚
â”‚ Optimistic updates needed          â”‚ TanStack     â”‚ Redux    â”‚ Fetch    â”‚
â”‚ Fastest development speed          â”‚ TanStack     â”‚ Fetch    â”‚ Redux    â”‚
â”‚ Long-term maintenance              â”‚ Redux        â”‚ Fetch    â”‚ TanStack*â”‚
â”‚ Team familiar with TanStack        â”‚ TanStack     â”‚ Redux    â”‚ Fetch    â”‚
â”‚ Team familiar with Redux           â”‚ Redux        â”‚ Fetch    â”‚ TanStack â”‚
â”‚ Existing Redux codebase            â”‚ Redux Async  â”‚ Fetch    â”‚ TanStack â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

* TanStack is heavy for MetaBuilder given existing Redux usage


DETAILED STRATEGY GUIDE
================================================================================

STRATEGY 1: NATIVE FETCH API
==============================

WHEN TO USE:
  âœ… Simple GET requests (no complex state)
  âœ… One-off API calls in non-critical paths
  âœ… Server-side code (Node.js)
  âœ… Minimal bundle size critical
  âœ… Low cognitive overhead needed
  âœ… No retry/caching needed
  âœ… Quick prototyping

WHEN NOT TO USE:
  âŒ Complex async state management
  âŒ Retry logic needed
  âŒ Request deduplication important
  âŒ Loading states required
  âŒ Error handling complex
  âŒ Observable state needed
  âŒ Rate limiting enforcement
  âŒ Multi-tenant scenarios

CODE PATTERN:

  // Basic fetch
  const response = await fetch('/api/users')
  const data = await response.json()

  // With error handling
  try {
    const response = await fetch('/api/users')
    if (!response.ok) throw new Error(`HTTP ${response.status}`)
    const data = await response.json()
    return data
  } catch (error) {
    console.error('Failed to fetch users:', error)
    throw error
  }

  // With timeout
  const controller = new AbortController()
  const timeout = setTimeout(() => controller.abort(), 5000)
  try {
    const response = await fetch('/api/users', { signal: controller.signal })
    return response.json()
  } finally {
    clearTimeout(timeout)
  }

  // In React component
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(false)
  
  useEffect(() => {
    setLoading(true)
    fetch('/api/users')
      .then(r => r.json())
      .then(d => setData(d))
      .finally(() => setLoading(false))
  }, [])

WHERE IN METABUILDER:
  - storybook/src/                (loading package configs)
  - emailclient/                  (simple page loads)
  - dbal/development/             (HTTP executor nodes)
  - codegen/src/lib/storage-adapter/ (Flask backend calls)

PROS:
  + Zero dependencies
  + Native browser API (all browsers)
  + Simple and straightforward
  + Works in Node.js v18+
  + Standards-based

CONS:
  - Manual state management
  - No built-in retry logic
  - Error handling verbose
  - Easy to make mistakes
  - Not observable


STRATEGY 2: REDUX ASYNC HOOKS (@metabuilder/hooks-async)
=========================================================

WHEN TO USE:
  âœ… Complex async state management
  âœ… Retries and error handling needed
  âœ… Request deduplication important
  âœ… Observable via Redux DevTools
  âœ… Multi-tenant scenarios
  âœ… Rate limiting enforcement
  âœ… Large async data pipelines
  âœ… Long-term maintenance important
  âœ… Redux already used in project

WHEN NOT TO USE:
  âŒ Simple one-off GET requests
  âŒ Minimal bundle size critical
  âŒ Redux not already in project
  âŒ Team unfamiliar with Redux
  âŒ Infinite scrolling (use TanStack)
  âŒ Optimistic updates critical (use TanStack)

CODE PATTERN:

  // Basic fetch
  import { useReduxAsyncData } from '@metabuilder/hooks-async'
  
  const { data, isLoading, error, refetch } = useReduxAsyncData(
    async () => {
      const res = await fetch('/api/users')
      return res.json()
    }
  )

  // With options
  const { data, isLoading, error, refetch } = useReduxAsyncData(
    async () => {
      const res = await fetch(`/api/users?tenantId=${tenantId}`)
      return res.json()
    },
    {
      maxRetries: 3,
      retryDelay: 1000,
      refetchInterval: 30000,      // Auto-refetch every 30s
      refetchOnFocus: true,         // Refetch when window regains focus
      onSuccess: (data) => console.log('Success:', data),
      onError: (error) => console.error('Error:', error),
      dependencies: [tenantId]      // Like useEffect deps
    }
  )

  // In component
  if (isLoading) return <Spinner />
  if (error) return <Error error={error} retry={refetch} />
  return <UserList users={data} />

  // Using mutation
  import { useReduxMutation } from '@metabuilder/hooks-async'
  
  const { mutate, isLoading: isSaving } = useReduxMutation(
    async (payload) => {
      const res = await fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(payload)
      })
      return res.json()
    },
    {
      onSuccess: (result) => {
        toast.success('User created!')
        refetch()  // Refetch list
      }
    }
  )

  // In form
  const handleSubmit = async (formData) => {
    await mutate(formData)
  }

WHERE IN METABUILDER:
  - redux/hooks-async/           (Implementation)
  - redux/api-clients/           (Wrapper)
  - frontends/nextjs/            (Should migrate)
  - workflowui/                  (Should migrate)
  - codegen/                     (Should migrate)

PROS:
  + Observable via Redux DevTools
  + Built-in retry logic
  + Automatic request deduplication
  + Consistent error handling
  + Multi-tenant filtering capable
  + Works with existing Redux store
  + 100% API compatible with TanStack
  + Fine-grained request lifecycle control

CONS:
  - Requires Redux setup
  - Larger bundle than Fetch alone
  - No infinite query support (yet)
  - No built-in optimistic updates
  - Team must understand Redux
  - Learning curve vs simple fetch


STRATEGY 3: TANSTACK REACT QUERY (Not Recommended for MetaBuilder)
===================================================================

STATUS IN METABUILDER:
  âŒ NOT ADOPTED - Replaced by Redux async hooks
  âŒ NOT RECOMMENDED - Redux solution sufficient

WHEN TANSTACK WOULD BE BETTER:
  âœ… No Redux in project
  âœ… Infinite query support critical
  âœ… Optimistic updates important
  âœ… Team experienced with TanStack
  âœ… Need offline-first behavior
  âœ… Don't want Redux dependency
  âœ… Minimal Redux configuration desired

WHY NOT USED IN METABUILDER:
  1. Redux already required for app state
  2. Redux async hooks provide 90% of features
  3. Better integration with Redux store
  4. Observable via Redux DevTools
  5. Reduced bundle size (10 KB vs 43.8 KB)
  6. Project philosophy: minimize external deps
  7. Redux provides fine-grained control

MIGRATION STRATEGY (if ever needed):
  Step 1: Create wrapper functions in @metabuilder/api-clients
  Step 2: Export TanStack Query hooks (useQuery, useMutation)
  Step 3: Gradually replace Redux hooks with TanStack
  Step 4: Remove Redux async middleware
  Step 5: Simplify Redux store (less async logic needed)

Note: API is 100% compatible, so migration is possible if needed


STRATEGY 4: AXIOS (Legacy - Not Recommended)
==============================================

STATUS IN METABUILDER:
  âš ï¸ FOUND in workflowui/package.json
  âŒ NO USAGE found in source code
  ğŸ¯ ACTION: Remove if unused, migrate if used

WHEN AXIOS IS USEFUL:
  âœ… Old browsers need automatic cookie handling
  âœ… Complex request transformation pipelines
  âœ… Built-in request/response interceptors
  âœ… Automatic JSON stringify/parse
  âœ… Automatic retry with exponential backoff
  âœ… Team already deeply familiar with Axios

WHY NOT RECOMMENDED FOR METABUILDER:
  1. Fetch handles 99% of use cases
  2. Redux hooks provide retry/interceptor logic
  3. No advantage over Fetch + Redux
  4. Adds unnecessary dependency
  5. Larger bundle than Fetch
  6. Fetch is native (no version conflicts)
  7. Project uses Redux for state management

MIGRATION PATH (if workflowui uses Axios):
  1. Audit all axios imports in workflowui source
  2. For each usage:
     - Convert axios.get() â†’ fetch() + useReduxAsyncData
     - Convert axios.post() â†’ fetch() + useReduxMutation
     - Convert interceptors â†’ Redux middleware
  3. Test workflowui fully (build + runtime)
  4. Remove axios from package.json
  5. Document decision in CLAUDE.md


STRATEGY 5: SWR (Not Applicable)
=================================

STATUS IN METABUILDER:
  âŒ NOT USED
  âŒ NOT RECOMMENDED

WHEN SWR IS USEFUL:
  âœ… Simple client-side GET requests only
  âœ… Built-in stale-while-revalidate behavior
  âœ… Minimal setup needed
  âœ… Only need automatic periodic refetch
  âœ… No mutations (POST/PUT/DELETE)
  âœ… Team wants minimal dependencies

WHY NOT USED IN METABUILDER:
  1. Redux async hooks provide everything SWR does
  2. SWR doesn't understand multi-tenant filtering
  3. Mutations required (POST/PUT/DELETE)
  4. Complex state management needed
  5. Redux already chosen as state store
  6. SWR overlaps with Redux responsibility
  7. Adds unnecessary library


================================================================================

API CLIENT HOOK PATTERN - RECOMMENDED APPROACH
===============================================

Our implementation (@metabuilder/api-clients):

LAYER 1: @metabuilder/api-clients
  â”œâ”€ useDBAL()       â†’ DBAL-specific queries
  â”œâ”€ useAsyncData()  â†’ Generic async data
  â”œâ”€ useMutation()   â†’ State mutations
  â””â”€ useGitHubFetcher() â†’ GitHub API

LAYER 2: @metabuilder/hooks-async
  â”œâ”€ useReduxAsyncData()  â†’ Redux-backed fetch
  â””â”€ useReduxMutation()   â†’ Redux-backed mutations

LAYER 3: @reduxjs/toolkit
  â”œâ”€ createAsyncThunk()   â†’ Async actions
  â”œâ”€ Slice state management
  â””â”€ Redux DevTools integration

LAYER 4: Native Fetch API
  â””â”€ Actual HTTP transport


RECOMMENDED USAGE:

For DBAL operations:
  ```typescript
  const { list, get, create } = useDBAL()
  const users = await list<User>('users', { filter: { tenantId } })
  ```

For async data fetching:
  ```typescript
  const { data, isLoading, error, refetch } = useAsyncData(
    async () => {
      const response = await fetch('/api/data')
      return response.json()
    }
  )
  ```

For mutations:
  ```typescript
  const { mutate, isLoading } = useMutation(
    async (payload) => {
      const response = await fetch('/api/create', {
        method: 'POST',
        body: JSON.stringify(payload)
      })
      return response.json()
    }
  )
  ```


================================================================================

DECISION: WHY REDUX OVER TANSTACK QUERY
========================================

Technical Comparison:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Criterion              â”‚ Redux Async     â”‚ TanStack Query   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Bundle size increase   â”‚ <10 KB          â”‚ 43.8 KB          â”‚
â”‚ Setup time             â”‚ 10 minutes      â”‚ 5 minutes        â”‚
â”‚ Learning curve         â”‚ Medium (Redux)  â”‚ Low (TRQ-specificâ”‚
â”‚ Integration w/ Redux   â”‚ Native          â”‚ Separate system  â”‚
â”‚ Observable state       â”‚ âœ… Redux store  â”‚ âš ï¸ TRQ DevTools  â”‚
â”‚ Team familiarity       â”‚ High (Redis)    â”‚ Low (TRQ)        â”‚
â”‚ Customization          â”‚ âœ… Complete     â”‚ âš ï¸ Limited       â”‚
â”‚ Multi-tenant support   â”‚ âœ… Dispatch arg â”‚ âš ï¸ Manual filter â”‚
â”‚ Rate limiting          â”‚ âœ… Middleware   â”‚ âš ï¸ Manual        â”‚
â”‚ Production use (MB)    â”‚ âœ… Yes (Phase 2)â”‚ âŒ No            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Business Rationale:

1. ALREADY INVESTED IN REDUX
   - Redux required for app state management
   - Redux middleware patterns established
   - Redux DevTools available and in use
   - Team trained on Redux
   â†’ Extending Redux to async is natural evolution

2. BUNDLE SIZE MATTERS
   - MetaBuilder emphasizes lightweight architecture
   - 43.8 KB (TanStack) vs 10 KB (Redux) = 4.4x difference
   - Mobile frontends (Qt6, CLI) sensitive to size
   - Next.js frontend wants minimal JS

3. OBSERVABILITY
   - Redux DevTools shows all state changes
   - Can debug async operations timeline
   - DevTools time-travel debugging
   - Can inspect exact request lifecycle
   â†’ TanStack DevTools less integrated with Redux store

4. FUTURE FLEXIBILITY
   - Can implement optimistic updates later
   - Can add infinite query support when needed
   - Can extend with custom async patterns
   - Not locked into TanStack's design decisions

5. PROJECT PHILOSOPHY
   - "95% JSON, 5% TypeScript infrastructure"
   - Minimize external libraries
   - Custom solutions when internal tools sufficient
   - Redux is already minimal infrastructure

6. MULTI-TENANT REQUIREMENTS
   - All queries must filter by tenantId
   - Redux dispatch can enforce this requirement
   - Thunk can validate tenantId before API call
   - TanStack would require component-level filtering (error-prone)

7. GRADUAL MIGRATION PATH
   - 100% API compatible with TanStack
   - Can migrate back to TanStack if needed (unlikely)
   - No consumer code changes required
   - Drop-in replacement approach proven (Phase 2 complete)


================================================================================

MIGRATION ROADMAP
=================

PHASE 1: âœ… COMPLETE (Redux Slice + Hooks Created)
  - Created @metabuilder/redux-slices with asyncDataSlice
  - Created @metabuilder/hooks-async with useReduxAsyncData/useMutation
  - Comprehensive Redux state machine for async operations
  - Full test coverage and TypeScript types

PHASE 2: âœ… COMPLETE (API Clients Layer)
  - Created @metabuilder/api-clients wrapper
  - useAsyncData delegates to Redux hooks
  - useMutation delegates to Redux hooks
  - 100% backward compatible with previous implementation
  - useGitHubFetcher implemented
  - useDBAL implemented

PHASE 3: IN PROGRESS (Consumer Migration)
  - codegen: Should migrate fetch patterns to useAsyncData
  - frontends/nextjs: Should migrate to useAsyncData
  - workflowui: Should remove axios, use useAsyncData
  - frontends/dbal: Already uses useDBAL, good pattern
  - postgres: Should migrate to useAsyncData

PHASE 4: DOCUMENTATION & ENFORCEMENT
  - Update CLAUDE.md with async patterns
  - Create linting rules (forbid standalone fetch in components)
  - Create ESLint plugin to enforce tenantId in dispatches
  - Comprehensive async pattern guide
  - E2E test scenarios for async operations


================================================================================

SUMMARY: WHEN TO USE WHAT
==========================

NATIVE FETCH:
  USE FOR:
    - Simple one-off GET requests
    - Server-side code (Node.js)
    - When Redux state not needed
    - Minimal bundle size critical
  
  AVOID FOR:
    - Complex state management
    - Retries and caching needed
    - Observable state required

REDUX ASYNC HOOKS:
  USE FOR:
    - Complex async operations
    - Retries, caching, deduplication
    - Observable state (Redux DevTools)
    - Multi-tenant scenarios
    - Rate limiting enforcement
  
  AVOID FOR:
    - Simple GET requests in non-critical paths
    - When Redux not already in use

TANSTACK QUERY:
  âŒ NOT RECOMMENDED FOR METABUILDER
  - Redux provides sufficient features
  - Adds unnecessary complexity
  - Reduces fine-grained control
  - Larger bundle
  
  WOULD CONSIDER IF:
    - Need infinite query support
    - No Redux in project
    - Team expert in TanStack

AXIOS:
  âŒ NOT RECOMMENDED
  - Fetch + Redux covers all use cases
  - Remove from workflowui
  
  WOULD USE IF:
    - Old browser compatibility critical
    - Complex interceptor pipelines needed

SWR:
  âŒ NOT APPLICABLE
  - Redux already provides caching
  - Doesn't fit multi-tenant requirements
  - Overlaps with Redux responsibility


================================================================================
END OF DECISION MATRIX
================================================================================

